***************************************************	SOME KEYWORDS	**************************************************
1) auto -> The auto keyword specifies that the type of the variable that is being declared will be automatically deducted from its initializer. In case of functions, if their return type is auto then that will be evaluated by return type expression at runtime.
	auto x = 4; 
    	auto y = 3.37; 
    	auto ptr = &x; 
    	cout << typeid(x).name() << endl 
         << typeid(y).name() << endl 
         << typeid(ptr).name() << endl;
	output -> 
	i
	d
	Pi
2) decltype -> It inspects the declared type of an entity or the type of an expression. Auto lets you declare a variable with particular type whereas decltype lets you extract the type from the variable so decltype is sort of an operator that evaluates the type of passed expression.
	// Data type of x is same as return type of fun1() 
    // and type of y is same as return type of fun2() 
    decltype(fun1()) x; 
    decltype(fun2()) y;
3)size() returns no of elements excluding the free spaces	-----(in vectors)
4) Array:--
	include<array>
	array<int,4> a;
	a.at(2); a[2]; a.front(); a.back(); a.fill(5); a.swap(b);  { where b is of same size and type as a}
	a.size(); // in array size will forever give the declared size of array no matter whether all places are filled or not
5) Pair:--
	its not a container class, but a standard class therefore we can use it by simply writing 'using namespace std;'
	pair<string, int> p1 = {"Tanishq", 88}; // cant do like this
	pair<string, int> p1 = make_pair("Tanishq", 88); // this the correct way
	p1.first; p1.second;	
	we can compare two pairs using >, <, ==, etc


